import os
import struct
import zlib

magic = b"NEKOPACK4A"


def read_u32le(fp):
    n, = struct.unpack("<I", fp.read(4))
    return int(n)


def read_meta(fp):
    """
    Read metadata from pak file
    :param fp: pak file
    :return: table_size, metas
    """
    fp.seek(0)
    rd = fp.read(len(magic))
    if rd != magic:
        raise AssertionError("invalid magic")

    table_size = read_u32le(fp)
    # print("table_size =", table_size)

    metas = []
    while True:
        name_size = read_u32le(fp)
        if name_size == 0:
            break

        fn = bytearray(fp.read(name_size))
        cksum = 0
        for c in fn:
            cksum = (cksum + c) & 0xffffffff
        offset = read_u32le(fp) ^ cksum
        size_comp = read_u32le(fp) ^ cksum
        fn_str = fn.strip(b"\x00").decode('utf-8')
        # print(fn_str, cksum, offset, size_comp, fn)
        metas.append({"fn": fn.hex(), "cksum": cksum, "offset": offset, "size_comp": size_comp, "fn_str": fn_str})

    return table_size, metas


def xor_file_data(data, size_comp):
    """
    encrypt/decrypt data by xor with a rolling key generated by size_comp
    :param data: data
    :param size_comp: len(compressed data) + 4
    :return: encrypted/decrypted data
    """
    key = ((size_comp >> 3) + 0x22) & 0xff
    data = bytearray(data)
    for k in range(len(data)):
        data[k] ^= key
        key = (key << 3) & 0xff
        if key == 0:
            break
    return data


def unpack_payload(pak_fp, meta):
    """
    unpack payload from pak using given metadata
    :param pak_fp: pak file
    :param meta: metadata
    """
    fn = meta["fn_str"]
    pak_fp.seek(meta["offset"])
    size_comp = meta["size_comp"]
    file_data = pak_fp.read(size_comp - 4)
    size_orig = read_u32le(pak_fp)
    compressed_data = xor_file_data(file_data, size_comp)
    data = zlib.decompress(compressed_data)
    if len(data) != size_orig:
        print("warning: original size of file ", fn, " not match! ", len(data), "!=", size_orig)
    return fn, data


def make_payload_from_file(fn):
    """
    compress and encode a file to make a payload
    :param fn: file path
    :return: payload_data, size_comp
    """
    with open(fn, 'rb') as f:
        # read file data
        data = f.read()
    size_orig = len(data)
    compressed = zlib.compress(data, 3)
    size_comp = len(compressed) + 4

    encrypted = xor_file_data(compressed, size_comp)
    encrypted += struct.pack("<I", size_orig)
    return encrypted, size_comp


def replace_payloads(metas, files_dir):
    """
    make new metadata and payloads by replacing old ones
    :param metas: old metadata
    :param files_dir: base directory to read new files from for replacing
    :return: metadata, payloads
    """
    body = []
    p = metas[0]["offset"]
    for i in range(len(metas)):
        fn = metas[i]["fn_str"]
        fn = os.path.join(files_dir, fn)
        data, size_comp = make_payload_from_file(fn)
        body.append(data)
        metas[i]["size_comp"] = size_comp
        metas[i]["offset"] = p
        p += len(data)
        # print(metas[i])
    return metas, body


def build_pak(table_size, metas, body):
    """
    build a new pak file
    :param table_size: table_size
    :param metas: metadata
    :param body: payloads list
    """
    header = b''
    for i in range(len(metas)):
        meta = metas[i]
        fn = bytearray.fromhex(meta["fn"])
        header += struct.pack("<I", len(fn))
        header += fn
        header += struct.pack("<I", meta["offset"] ^ meta["cksum"])
        header += struct.pack("<I", meta["size_comp"] ^ meta["cksum"])
    header += b'\x00\x00\x00\x00'

    if len(header) != table_size:
        raise AssertionError("table_size unmatch! {} != {}".format(len(header), table_size))

    return magic + struct.pack("<I", table_size) + header + b''.join(body)
